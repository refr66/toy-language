// MLIR representation of sBPF program
// Generated by sbpf-frontend
// Using memref.alloca for SSA-compliant register file

module {
  // Internal function: _ZN13relative_call12function_sum17h8da3f9048852644bE
  func.func @_ZN13relative_call12function_sum17h8da3f9048852644bE(%arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64) -> i64 {
    // ========== Register File Allocation ==========
    // Registers r0-r10 as memory locations to maintain SSA
    %reg0 = memref.alloca() : memref<i64>
    %reg1 = memref.alloca() : memref<i64>
    %reg2 = memref.alloca() : memref<i64>
    %reg3 = memref.alloca() : memref<i64>
    %reg4 = memref.alloca() : memref<i64>
    %reg5 = memref.alloca() : memref<i64>
    %reg6 = memref.alloca() : memref<i64>
    %reg7 = memref.alloca() : memref<i64>
    %reg8 = memref.alloca() : memref<i64>
    %reg9 = memref.alloca() : memref<i64>
    %reg10 = memref.alloca() : memref<i64>
  
    // ========== Register Initialization ==========
    %c0_0 = arith.constant 0 : i64
    memref.store %c0_0, %reg0[] : memref<i64>  // r0 = 0 (return)
    memref.store %arg1, %reg1[] : memref<i64>  // r1 = arg1
    memref.store %arg2, %reg2[] : memref<i64>  // r2 = arg2
    memref.store %arg3, %reg3[] : memref<i64>  // r3 = arg3
    memref.store %arg4, %reg4[] : memref<i64>  // r4 = arg4
    memref.store %arg5, %reg5[] : memref<i64>  // r5 = arg5
    memref.store %c0_0, %reg6[] : memref<i64>  // r6 = 0 (callee-saved)
    memref.store %c0_0, %reg7[] : memref<i64>  // r7 = 0 (callee-saved)
    memref.store %c0_0, %reg8[] : memref<i64>  // r8 = 0 (callee-saved)
    memref.store %c0_0, %reg9[] : memref<i64>  // r9 = 0 (callee-saved)
    %stack_base_1 = arith.constant 0x200000000 : i64  // Stack base
    memref.store %stack_base_1, %reg10[] : memref<i64>  // r10 = stack pointer
  
    cf.br ^bb13
  
    // ========== Basic Blocks ==========
  ^bb13:  // _ZN13relative_call12function_sum17h8da3f9048852644bE
    // PC 000d: mov64 r0, r2
    %dst_2 = memref.load %reg0[] : memref<i64>
    %src_4 = memref.load %reg2[] : memref<i64>
    memref.store %src_4, %reg0[] : memref<i64>
    // PC 000e: add64 r0, r1
    %dst_5 = memref.load %reg0[] : memref<i64>
    %src_7 = memref.load %reg1[] : memref<i64>
    %res_6 = arith.addi %dst_5, %src_7 : i64
    memref.store %res_6, %reg0[] : memref<i64>
    // PC 000f: exit
    %ret_8 = memref.load %reg0[] : memref<i64>
    func.return %ret_8 : i64
  
  }

  // Internal function: _ZN13relative_call18function_stack_ref17h992bbe44bbc125c9E
  func.func @_ZN13relative_call18function_stack_ref17h992bbe44bbc125c9E(%arg1: i64, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64) -> i64 {
    // ========== Register File Allocation ==========
    // Registers r0-r10 as memory locations to maintain SSA
    %reg0 = memref.alloca() : memref<i64>
    %reg1 = memref.alloca() : memref<i64>
    %reg2 = memref.alloca() : memref<i64>
    %reg3 = memref.alloca() : memref<i64>
    %reg4 = memref.alloca() : memref<i64>
    %reg5 = memref.alloca() : memref<i64>
    %reg6 = memref.alloca() : memref<i64>
    %reg7 = memref.alloca() : memref<i64>
    %reg8 = memref.alloca() : memref<i64>
    %reg9 = memref.alloca() : memref<i64>
    %reg10 = memref.alloca() : memref<i64>
  
    // ========== Register Initialization ==========
    %c0_0 = arith.constant 0 : i64
    memref.store %c0_0, %reg0[] : memref<i64>  // r0 = 0 (return)
    memref.store %arg1, %reg1[] : memref<i64>  // r1 = arg1
    memref.store %arg2, %reg2[] : memref<i64>  // r2 = arg2
    memref.store %arg3, %reg3[] : memref<i64>  // r3 = arg3
    memref.store %arg4, %reg4[] : memref<i64>  // r4 = arg4
    memref.store %arg5, %reg5[] : memref<i64>  // r5 = arg5
    memref.store %c0_0, %reg6[] : memref<i64>  // r6 = 0 (callee-saved)
    memref.store %c0_0, %reg7[] : memref<i64>  // r7 = 0 (callee-saved)
    memref.store %c0_0, %reg8[] : memref<i64>  // r8 = 0 (callee-saved)
    memref.store %c0_0, %reg9[] : memref<i64>  // r9 = 0 (callee-saved)
    %stack_base_1 = arith.constant 0x200000000 : i64  // Stack base
    memref.store %stack_base_1, %reg10[] : memref<i64>  // r10 = stack pointer
  
    cf.br ^bb0
  
    // ========== Basic Blocks ==========
  ^bb0:  // _ZN13relative_call18function_stack_ref17h992bbe44bbc125c9E
    // PC 0000: ldxdw r0, [r1]
    %base_2 = memref.load %reg1[] : memref<i64>
    %val_3 = sbpf.load %base_2 : i64
    memref.store %val_3, %reg0[] : memref<i64>
    // PC 0001: add64 r0, 1
    %dst_4 = memref.load %reg0[] : memref<i64>
    %imm_6 = arith.constant 1 : i64
    %res_5 = arith.addi %dst_4, %imm_6 : i64
    memref.store %res_5, %reg0[] : memref<i64>
    // PC 0002: stxdw [r1], r0
    %base_7 = memref.load %reg1[] : memref<i64>
    %src_8 = memref.load %reg0[] : memref<i64>
    sbpf.store %base_7, %src_8 : i64
    // PC 0003: exit
    %ret_9 = memref.load %reg0[] : memref<i64>
    func.return %ret_9 : i64
  
  }

  // Entry point function
  func.func @entrypoint(%arg0: i64) -> i64 {
    // ========== Register File Allocation ==========
    // Registers r0-r10 as memory locations to maintain SSA
    %reg0 = memref.alloca() : memref<i64>
    %reg1 = memref.alloca() : memref<i64>
    %reg2 = memref.alloca() : memref<i64>
    %reg3 = memref.alloca() : memref<i64>
    %reg4 = memref.alloca() : memref<i64>
    %reg5 = memref.alloca() : memref<i64>
    %reg6 = memref.alloca() : memref<i64>
    %reg7 = memref.alloca() : memref<i64>
    %reg8 = memref.alloca() : memref<i64>
    %reg9 = memref.alloca() : memref<i64>
    %reg10 = memref.alloca() : memref<i64>
  
    // ========== Register Initialization ==========
    %c0_0 = arith.constant 0 : i64
    memref.store %c0_0, %reg0[] : memref<i64>  // r0 = 0 (return)
    memref.store %arg0, %reg1[] : memref<i64>  // r1 = input context
    memref.store %c0_0, %reg6[] : memref<i64>  // r6 = 0 (callee-saved)
    memref.store %c0_0, %reg7[] : memref<i64>  // r7 = 0 (callee-saved)
    memref.store %c0_0, %reg8[] : memref<i64>  // r8 = 0 (callee-saved)
    memref.store %c0_0, %reg9[] : memref<i64>  // r9 = 0 (callee-saved)
    %stack_base_1 = arith.constant 0x200000000 : i64  // Stack base
    memref.store %stack_base_1, %reg10[] : memref<i64>  // r10 = stack pointer
  
    cf.br ^bb4
  
    // ========== Basic Blocks ==========
  ^bb4:  // entrypoint
    // PC 0004: ldxb r6, [r1]
    %base_2 = memref.load %reg1[] : memref<i64>
    %val_3 = sbpf.load %base_2 : i8
    %ext_4 = arith.extui %val_3 : i8 to i64
    memref.store %ext_4, %reg6[] : memref<i64>
    // PC 0005: stxdw [r10-256], r6
    %base_5 = memref.load %reg10[] : memref<i64>
    %src_6 = memref.load %reg6[] : memref<i64>
    %off_7 = arith.constant -256 : i64
    %addr_8 = arith.addi %base_5, %off_7 : i64
    sbpf.store %addr_8, %src_6 : i64
    // PC 0006: mov64 r1, r10
    %dst_9 = memref.load %reg1[] : memref<i64>
    %src_11 = memref.load %reg10[] : memref<i64>
    memref.store %src_11, %reg1[] : memref<i64>
    // PC 0007: add64 r1, -256
    %dst_12 = memref.load %reg1[] : memref<i64>
    %imm_14 = arith.constant -256 : i64
    %res_13 = arith.addi %dst_12, %imm_14 : i64
    memref.store %res_13, %reg1[] : memref<i64>
    // PC 0008: call _ZN13relative_call18function_stack_ref17h992bbe44bbc125c9E
    %arg1_15 = memref.load %reg1[] : memref<i64>
    %arg2_16 = memref.load %reg2[] : memref<i64>
    %arg3_17 = memref.load %reg3[] : memref<i64>
    %arg4_18 = memref.load %reg4[] : memref<i64>
    %arg5_19 = memref.load %reg5[] : memref<i64>
    %ret_20 = func.call @_ZN13relative_call18function_stack_ref17h992bbe44bbc125c9E(%arg1_15, %arg2_16, %arg3_17, %arg4_18, %arg5_19) : (i64, i64, i64, i64, i64) -> i64
    memref.store %ret_20, %reg0[] : memref<i64>  // r0 = return value
    cf.br ^bb9  // fallthrough
  
  ^bb9:  // block_9
    // PC 0009: mov64 r1, r0
    %dst_21 = memref.load %reg1[] : memref<i64>
    %src_23 = memref.load %reg0[] : memref<i64>
    memref.store %src_23, %reg1[] : memref<i64>
    // PC 000a: mov64 r2, r6
    %dst_24 = memref.load %reg2[] : memref<i64>
    %src_26 = memref.load %reg6[] : memref<i64>
    memref.store %src_26, %reg2[] : memref<i64>
    // PC 000b: call _ZN13relative_call12function_sum17h8da3f9048852644bE
    %arg1_27 = memref.load %reg1[] : memref<i64>
    %arg2_28 = memref.load %reg2[] : memref<i64>
    %arg3_29 = memref.load %reg3[] : memref<i64>
    %arg4_30 = memref.load %reg4[] : memref<i64>
    %arg5_31 = memref.load %reg5[] : memref<i64>
    %ret_32 = func.call @_ZN13relative_call12function_sum17h8da3f9048852644bE(%arg1_27, %arg2_28, %arg3_29, %arg4_30, %arg5_31) : (i64, i64, i64, i64, i64) -> i64
    memref.store %ret_32, %reg0[] : memref<i64>  // r0 = return value
    cf.br ^bb12  // fallthrough
  
  ^bb12:  // block_12
    // PC 000c: exit
    %ret_33 = memref.load %reg0[] : memref<i64>
    func.return %ret_33 : i64
  
  }

}
